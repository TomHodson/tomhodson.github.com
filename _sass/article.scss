article {
    padding-bottom: 20px;
}

span.link-block {
    color: #4a4a4a;
    font-size: 1em;
    line-height: 1.5;
    text-align: center!important;
}

a.paper-link-button {
    text-decoration: none;
    user-select: none;

    display: inline-flex;
    align-items: center;
    
    cursor: pointer;
    padding-bottom: calc(.5em - 1px);
    padding-top: calc(.5em - 1px);
    background-color: #363636;
    color: #fff;
    font-size: 1rem;
    border-radius: 2rem;
    padding-left: calc(1em + .25em);
    padding-right: calc(1em + .25em);
}

span.icon {
    user-select: none;
    cursor: pointer;
    align-items: center;
    display: inline-flex;
    justify-content: center;
    height: 1.5em;
    width: 1.5em;
    margin-left: calc(-.5em - 1px);
    margin-right: .25em;
}

span.icon svg {
    width: .75em;
}

// aside details summary element
// <details class="aside" markdown=1>
// <summary>Why do we still have to bind in free-threaded python?</summary>
// My understanding is that, even in free-threaded python, we still a need a mechanism to keep track of which threads are currently bound to the interpreter because the python garbage collector can only run when no threads are bound to the interpreter. Presumably this means we would need to be careful to give the GC a chance to run every now and then but I haven't looked deeply into this aspect.
// </details>

details.aside[open] > summary {
        margin-bottom: 0.5em;
}

details.aside[open] > summary::after {
    content: "△";
}

details.aside > summary::after {
    content: "▽";
    color: var(--theme-highlight-color);
}

details.aside {
    summary {
        display: flex;
        justify-content: space-between;
        font-weight: 700;
    }

    p {
    margin: 0;
    }
    padding: 1em;
    margin-top: 1em;
    margin-bottom: 1em;
    background-color: var(--theme-highlight-color-transparent);
    border-radius: 10px;
}